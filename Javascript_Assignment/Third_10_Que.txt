1.What is a callback function?

  A callback function is a function passed as an argument to another function, intended to be executed after the completion of some operation within the outer function. 
  
  Asynchronous Operations: JavaScript is single-threaded, meaning it executes code sequentially. 
  However, many operations, such as fetching data from an API, reading files, or handling user input, are asynchronous and can take time. 
  Callbacks allow the program to continue executing other code while waiting for these operations to complete, preventing the application from freezing. 
  Once the asynchronous task finishes, the callback function is invoked to handle the result or perform subsequent actions.

  event Handling: Callbacks are fundamental to handling events in web development. When a user interacts with an element
   a callback function is executed in response to that specific event.

   Code Organization and Reusability

  ex: 

  function processUserInput(name, callback) {
    // Simulate some processing or asynchronous task
    setTimeout(() => {
      const greetingMessage = `Hello, ${name}!`;
      callback(greetingMessage); // Execute the callback function with the result
    }, 1000); // Simulate a 1-second delay
  }

  function displayGreeting(message) {
    console.log(message);
  }

  // Call processUserInput and pass displayGreeting as the callback
  processUserInput("Alice", displayGreeting);
  // Expected output after 1 second: "Hello, Alice!"


2. What are arrow functions, and how are they different from normal functions?

  Arrow functions are a concise syntax introduced in ES6 (ECMAScript 2015) for writing JavaScript functions. 
  They provide a shorter way to define functions compared to traditional function expressions.

  Differences from Normal Functions:
  Syntax:
  Normal Function: Uses the function keyword.
  Arrow Function: Uses the => (arrow) operator. It can be more compact, especially for single-expression functions where return and curly braces can be omitted.
  this Binding:
  Normal Function: Has its own this context, which is dynamically determined by how the function is called.
  Arrow Function: Does not have its own this binding. It lexically inherits this from its surrounding (parent) scope. This is a significant difference, particularly in object methods or callbacks.
  arguments Object:
  Normal Function: Has its own arguments object, which contains all arguments passed to the function.
  Arrow Function: Does not have its own arguments object. To access arguments, rest parameters (...args) must be used.

  ex: 
  // Normal Function
  function add(a, b) {
    return a + b;
  }
  console.log(add(2, 3)); // Output: 5

  // Arrow Function (concise for single expression)
  const subtract = (a, b) => a - b;
  console.log(subtract(5, 2)); // Output: 3

  // Arrow Function with multiple statements (requires curly braces and return)
  const multiply = (a, b) => {
    let result = a * b;
    return result;
  };
  console.log(multiply(4, 5)); // Output: 20

  // 'this' binding example
  const person = {
    name: "Alice",
    normalMethod: function() {
      console.log("Normal method 'this.name':", this.name); // 'this' refers to 'person'
    },
    arrowMethod: () => {
      console.log("Arrow method 'this.name':", this.name); // 'this' refers to the global object (window/undefined in strict mode)
    }
  };

  person.normalMethod();
  person.arrowMethod();



3. What is the value of this inside an arrow function?

  Inside an arrow function, the value of this is determined by its lexical scope, not by how the function is called. 
  This means that this in an arrow function refers to the value of this in the closest enclosing context where the arrow function is defined. 

  ex: 

  // Global scope
  const globalObject = this; // In a browser, this would be the window object

  const arrowFunctionInGlobal = () => {
    console.log(this === globalObject); // true
  };

  arrowFunctionInGlobal(); // 'this' refers to the global object

  const myObject = {
    name: 'Example Object',
    regularMethod: function() {
      console.log(this.name); // 'this' refers to myObject
      const arrowFunctionInsideMethod = () => {
        console.log(this.name); // 'this' still refers to myObject (inherited from regularMethod's scope)
      };
      arrowFunctionInsideMethod();
    },
    arrowMethod: () => {
      console.log(this.name); // 'this' refers to the global object (inherited from the scope where myObject was defined)
    }
  };

  myObject.regularMethod();
  myObject.arrowMethod();



4. What is function currying?

  Function currying is a technique in functional programming where a function that takes multiple arguments is transformed into a 
  series of functions, each taking a single argument. This allows for the partial application of functions, 
  meaning you can create new functions by fixing some of the arguments of an existing function

  ex:

  function add(a, b, c) {
    return a + b + c;
  }

  console.log(add(1, 2, 3)); // Output: 6



5. What is the difference between call, apply, and bind?

  the main difference is that call() and apply() execute the function immediately, while bind() returns a new function that can be invoked later. 
  Both call() and apply() are used to set the this context, with call() taking arguments individually and apply() accepting them as an array. 

  ex: 

  const person = {
    firstName: "John",
    lastName: "Doe",
    getFullName: function(city, profession) {
      return `${this.firstName} ${this.lastName} from ${city} works as a ${profession}.`;
    }
  };

  const person2 = {
    firstName: "Jane",
    lastName: "Smith"
  };

  // --- Using call() ---
  // Executes immediately, arguments are passed individually.
  console.log(person.getFullName.call(person2, "New York", "Engineer"));
  // Output: Jane Smith from New York works as a Engineer.

  // --- Using apply() ---
  // Executes immediately, arguments are passed as an array.
  const args = ["London", "Doctor"];
  console.log(person.getFullName.apply(person2, args));
  // Output: Jane Smith from London works as a Doctor.

  // --- Using bind() ---
  // Does not execute immediately. Creates a new function.
  const boundGetFullName = person.getFullName.bind(person2, "Paris");
  // 'boundGetFullName' now has 'this' set to person2 and "Paris" is a pre-set argument.

  // Now we can call the new function later, and only need to pass the remaining arguments.
  console.log(boundGetFullName("Artist"));
  // Output: Jane Smith from Paris works as a Artist.



6. How do you pass parameters by reference vs value?

  1.Pass by Value (for Primitive Data Types):
  Primitive data types in JavaScript include string, number, boolean, null, undefined, and symbol. When a primitive value is passed to
  a function, a copy of that value is created and assigned to the function's parameter. 
  Any modifications to the parameter inside the function do not affect the original variable outside the function.

  ex: 

  function modifyPrimitive(num) {
    num = num + 10; // Modifies the local copy of 'num'
    console.log("Inside function (primitive):", num);
  }

  let originalNumber = 5;
  console.log("Before function call (primitive):", originalNumber);
  modifyPrimitive(originalNumber);
  console.log("After function call (primitive):", originalNumber); // originalNumber remains 5

  2. Pass by Reference (for Non-Primitive Data Types):
  Non-primitive data types (also known as reference types) in JavaScript include objects (including plain objects, arrays, and functions). 
  When a non-primitive value is passed to a function, a reference (memory address) to the original object is passed. 
  This means that both the original variable and the function parameter point to the same object in memory. 
  Any modifications made to the object's properties inside the function will affect the original object outside the function. 

ex : 

  function modifyObject(obj) {
    obj.property = "updated value"; // Modifies the original object's property
    console.log("Inside function (object):", obj);
  }

  let originalObject = { property: "original value" };
  console.log("Before function call (object):", originalObject);
  modifyObject(originalObject);
  console.log("After function call (object):", originalObject); // originalObject's property is updated



7. What are default parameters in ES6?

  Default parameters in ES6 (ECMAScript 2015) allow you to initialize function parameters with default values. 
  This means that if a function is called without providing an argument for a parameter, or if undefined is explicitly passed as the argument, 
  the default value assigned to that parameter will be used instead. 

ex:


  function greet(name = "Guest", greeting = "Hello") {
    console.log(`${greeting}, ${name}!`);
  }

  // Case 1: No arguments provided
  greet(); 
  // Output: Hello, Guest!

  // Case 2: Only 'name' argument provided
  greet("Alice"); 
  // Output: Hello, Alice!

  // Case 3: Both arguments provided
  greet("Bob", "Hi"); 
  // Output: Hi, Bob!

  // Case 4: 'undefined' explicitly passed for a parameter
  greet(undefined, "Greetings"); 
  // Output: Greetings, Guest! 
  // (name defaults to "Guest" because undefined was passed)

  greet("Charlie", undefined);
  // Output: Hello, Charlie!
  // (greeting defaults to "Hello" because undefined was passed)



8. What is recursion in JavaScript?

  Recursion in JavaScript is a programming technique where a function calls itself.

  Base Case: This is the condition that determines when the recursion should stop. Without a base case, the function would call 
  itself indefinitely, leading to a stack overflow error. 
  Recursive Case: This is the part of the function where it calls itself with a modified input, moving closer to the base case. 



9. What is the difference between function declaration and expression?

Function Declaration:
A function declaration defines a named function as a standalone statement. 
It starts with the function keyword, followed by the function name, parameters, and the function body.

ex:

  function greet(name) {
    return `Hello, ${name}!`;
  }

  console.log(greet("Alice")); // Output: Hello, Alice!

  Function Expression:
  A function expression defines a function as part of an expression, often assigned to a variable. It can be named or anonymous.

  ex:

  // Anonymous function expression
  const sayHello = function(name) {
    return `Hello, ${name}!`;
  };

  console.log(sayHello("Bob")); // Output: Hello, Bob!

  // Named function expression (name is local to the function's scope)
  const factorial = function calculateFactorial(n) {
    if (n <= 1) {
      return 1;
    }
    return n * calculateFactorial(n - 1);
  };

  console.log(factorial(5)); // Output: 120




10. What is a generator function?

A generator function in JavaScript is a special type of function that can be paused and resumed, allowing 
it to generate a sequence of values over time rather than returning a single value and terminating. 
This capability is achieved through the yield keyword. 
When a generator function is called, it returns a Generator object, which is an iterator. 

ex:

  function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
    return "Finished!"; // The return value is the final value when done is true
  }

  // Create a generator object
  const generator = numberGenerator();

  console.log(generator.next()); // Output: { value: 1, done: false }
  console.log(generator.next()); // Output: { value: 2, done: false }
  console.log(generator.next()); // Output: { value: 3, done: false }
  console.log(generator.next()); // Output: { value: 'Finished!', done: true }
  console.log(generator.next()); // Output: { value: undefined, done: true }