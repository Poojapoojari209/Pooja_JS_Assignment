1. What is JavaScript and how does it differ from Java?
    
Java:                                                                 
    A compiled, object-oriented programming language designed for building robust, large-scale applications.
    It requires a Java Virtual Machine (JVM) for execution.
    Applications typically run on a JVM, allowing them to be platform-independent.
    Statically typed, meaning variable types are declared and checked at compile time.
    Java has a thread-based approach to concurrency.

JavaScript:
    An interpreted, dynamically-typed scripting language primarily for web browsers, enhancing interactivity.
    It runs directly in the browser's JavaScript engine.
    Executed within web browsers, though Node.js extends its use to server-side environments.
    Dynamically typed, meaning variable types are determined at runtime.
    Javascript has an event-based approach to concurrency.


2.What are the primitive and non-primitive data types in JavaScript?
    Primitive Data Types:
    
    Primitive data types represent single, immutable values. When you assign a primitive value to a variable, the variable directly holds that value.
    
    String: Represents textual data.
    example:
        let name = "Alice";
        
    Number: Represents numerical data, including integers and floating-point numbers.
    example:
        let age = 30;
        let price = 19.99;

    Boolean: Represents a logical entity and can only have two values: true or false.
    example:
        let isActive = true;

    Undefined: Represents a variable that has been declared but not yet assigned a value. 
    example:
        let unassignedVariable; // Value is undefined

    Null: Represents the intentional absence of any object value. It is a primitive value.
    example:
         let emptyValue = null;
    
    Symbol: Represents a unique and immutable identifier, often used to create unique property keys for objects.
    example:
        const id = Symbol('uniqueId');

   
    Non-Primitive (Reference) Data Types:

    Non-primitive data types hold multiple values or object. Variables holding non-primitive values do not directly store the value; instead, they store a reference (memory address) to the location where the actual data is stored in memory.
    
    Object: The most fundamental non-primitive type, used to store collections of key-value pairs.
    example:
        let person = {
            firstName: "John",
            lastName: "Doe"
        };

    Array: A special type of object collection of different element with different datatype which ordered collection.
    example:
        let colors = ["red", "green", "blue"];

    Function: A block of code designed to perform a particular task. Functions are also a type of object.
    example:
        function greet(name) {
            return "Hello, " + name;
        }



3. What is the difference between var, let, and const? 
The main difference is that var has function scope, while let and const have block scope. 
var can be reassigned and redecalred, let can be reassigned but not redeclared in the same scope, 
and const cannot be reassigned or redeclared after initialization. 

Feature 	                            var	                                    let	                                                const
Scope	                                Function scope	                        Block scope	                                        Block scope
Reassignable	                        Yes	                                    Yes	                                                No
Redeclarable	                        Yes	                                    No	                                                No
Hoisting	                            Hoisted and initializedto undefined	    Hoisted but not initialized (Temporal Dead Zone)	Hoisted but not initialized (Temporal Dead Zone)

    // var example
    function varExample() {
    var x = 1;
    if (true) {
        var x = 10; // Reassigns the outer 'x'
        console.log("Inside block:", x); // Output: 10
    }
    console.log("Outside block:", x); // Output: 10 (x was changed globally)
    }
    varExample();


    // let example
    function letExample() {
    let y = 2;
    if (true) {
        let y = 20; // Creates a new 'y' with block scope
        console.log("Inside block:", y); // Output: 20
    }
    console.log("Outside block:", y); // Output: 2 (the original 'y' is untouched)
    }
    letExample();


    // const example
    function constExample() {
    const PI = 3.14;
    // PI = 3.14159; // This would cause an error
    console.log(PI);

    const MY_OBJECT = { value: 1 };
    MY_OBJECT.value = 2; // You can still change the contents of the object
    console.log(MY_OBJECT.value); // Output: 2
    }
    constExample();



4. What is hoisting?
    Hoisting is JavaScript's default behavior of moving all declarations to the top of the current scope Or
    Hoisting in JavaScript is a mechanism where variable and function declarations are conceptually moved to the top of their containing scope during the compile phase, 
    before the code is executed. This means that you can use variables and call functions before they are formally declared in your code. 
    Here's a breakdown of how hoisting works for different types of declarations:
    
    1. Variable Hoisting (with var)
    Variable declarations (var): The var keyword hoists the declaration to the top of its scope and initializes it with undefined. 
    The actual assignment value is not hoisted, which can lead to unexpected results. 
    ex:

    console.log(myVar); // Output: undefined
    var myVar = 10;
    console.log(myVar); // Output: 10
    
    2. Variable Hoisting (with let and const)
   Variable declarations (let and const): Variables declared with let and const are also hoisted, but they are not initialized. 
   They are placed in a "temporal dead zone" (TDZ) until the line where they are declared is executed. 
   Trying to access them before their declaration will result in a ReferenceError
    
    ex:
    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
    let myLet = 20;
    console.log(myLet); // Output: 20

    // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
    const myConst = 30;
    console.log(myConst); // Output: 30
    
    3. Function Hoisting
    Function declarations are fully hoisted. Both the function name and its definition are hoisted to the top of their containing scope. This allows you to call a function declaration before it is defined in the code.
    ex:

    greet(); // Output: Hello!

    function greet() {
    console.log("Hello!");
    }

    4. Function expressions: Function expressions are not hoisted in the same way as function declarations. 
    Only the variable declaration (if var is used) is hoisted and initialized to undefined.
Example:

    var sayHi = function() {
    console.log("Hi!");
    };

    sayHi(); // Output: Hi!


5. What is the difference between == and ===?
    The == operator is known as the loose equality operator. 
    It compares two values for equality after performing type coercion, meaning it converts the values to the same type before comparing them.
    The === operator is called the strict equality operator. 
    It checks for equality without type conversion, meaning both the value and the type must be exactly the same for the comparison to return true.

6. What are truthy and falsy values in JavaScript?

    Falsy Values:
    
    false: The boolean primitive false.
    0: The number zero (including -0).
    0n: The BigInt zero.
    "": An empty string.
    null: Represents the intentional absence of any object value.
    undefined: A variable that has not been assigned a value.
    NaN: "Not a Number," a result of an invalid or undefined mathematical operation.
    
    Truthy Values:
    
    true (the boolean primitive)
    Any non-zero number (e.g., 1, -42, 3.14, Infinity)
    Any non-empty string (e.g., "hello", "false", "0")
    Empty objects {}
    Empty arrays []
    Functions
    Dates
    Symbols

    Example:


    if (0) {
    console.log("This will not execute because 0 is falsy.");
    }

    if ("hello") {
    console.log("This will execute because 'hello' is truthy.");
    }

    let myVariable;
    if (myVariable) {
    console.log("This will not execute because myVariable is undefined (falsy).");
    }

    if ({}) {
    console.log("This will execute because an empty object is truthy.");
    }


7. What is the use of the typeof operator?

The typeof operator is used to determine the data type of a variable or expression. 
Primary uses of the typeof operator:

Type Checking: It allows developers to check the data type of a variable or value before performing operations that are specific to that type. 
This helps prevent errors and ensures code robustness.
ex:

    let myVariable = "Hello";
    if (typeof myVariable === "string") {
        console.log("It's a string!");
    }




8. What is NaN and how can you check for it?

    NaN stands for Not a Number.
    In JavaScript, NaN is a special value that represents an invalid number.
    It appears when a calculation cannot produce a valid numeric result.

    ex: 

    console.log(0 / 0);            // NaN
    console.log("hello" - 5);      // NaN
    console.log(parseInt("abc"));  // NaN
    console.log(Math.sqrt(-1));    // NaN

    console.log(typeof NaN);   // "number"

 9. What is the difference between undefined and null?

    
    undefined: This indicates that a variable has been declared but has not yet been assigned a value. 

    it is declared but not assigned.
    A function does not return anything.
    You try to access a missing property.

    ex: let a;
    console.log(a);       // undefined

    function test() {}
    console.log(test());  // undefined

    let obj = {};
    console.log(obj.x);   // undefined


    null: This represents the intentional absence of any object value. It is explicitly assigned by a developer to indicate that a variable or property currently 
    holds no value.

    let user = null; // user is intentionally empty
    user = { name: "sanvi" }; // now user has data

10. What is type coercion in JavaScript?

    Type coercion in JavaScript refers to the automatic or implicit conversion of values from one data type to another during certain operations. 
    This happens when JavaScript encounters an operation involving values of different types and needs to convert one or both of them to a compatible type to
    perform the operation. 
    
    Types of Coercion:
    
    Implicit Coercion: This is the automatic conversion performed by JavaScript without explicit instructions from the developer. The examples above 
    illustrate implicit coercion.

    // Number to String
    let result1 = 5 + "hello"; // "5hello" (number 5 is converted to string "5")

    // String to Number
    let result2 = "10" - 2; // 8 (string "10" is converted to number 10)
    let result3 = "10" * "2"; // 20 (both strings are converted to numbers)


    Explicit Coercion (Type Casting): TExplicit type conversion in JavaScript, also known as type casting, involves manually converting a value from one data type to another using built-in functions or methods.
     For example, Number("10") converts the string "10" to the number 10.

     // To Number
    let stringNum = "123";
    let num1 = Number(stringNum); // 123 (converts string to number)
    let num2 = parseInt("45.6"); // 45 (parses integer part of string)
    let num3 = parseFloat("45.6"); // 45.6 (parses float part of string)
   
    // To String
    let numberVal = 123; 
    let str1 = String(numberVal); // "123" (converts number to string)