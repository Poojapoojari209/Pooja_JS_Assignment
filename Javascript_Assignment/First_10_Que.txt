1. What is JavaScript and how does it differ from Java?
    JavaScript is a high-level, interpreted scripting language primarily known for enabling interactive and dynamic content on web pages. 
    It is executed directly within web browsers (client-side) and can also be used for server-side development with platforms like Node.js.

    Java is a class-based, object-oriented programming language designed for building robust, large-scale applications. 
    It is a compiled language, meaning its code is translated into bytecode before execution on a Java Virtual Machine (JVM). 
    Java is widely used for server-side applications, Android mobile development, enterprise systems, and more. 


2.What are the primitive and non-primitive data types in JavaScript?
    Primitive Data Types:
    
    Primitive data types represent single, immutable values. When you assign a primitive value to a variable, the variable directly holds that value.
    
    String: Represents textual data.
    example:
        let name = "Alice";
        
    Number: Represents numerical data, including integers and floating-point numbers.
    example:
        let age = 30;
        let price = 19.99;

    Boolean: Represents a logical entity and can only have two values: true or false.
    example:
        let isActive = true;

    Undefined: Represents a variable that has been declared but not yet assigned a value. 
    example:
        let unassignedVariable; // Value is undefined

    Null: Represents the intentional absence of any object value. It is a primitive value.
    example:
         let emptyValue = null;
    
    Symbol: Represents a unique and immutable identifier, often used to create unique property keys for objects.
    example:
        const id = Symbol('uniqueId');

    BigInt: Represents integer numbers of arbitrary length, exceeding the safe integer limit of Number.
    example:
        const largeNumber = 9007199254740991n; // The 'n' suffix denotes a BigInt

    Non-Primitive (Reference) Data Types:

    Non-primitive data types are used to store collections of data or more complex entities. Variables holding non-primitive values do not directly store the value; instead, they store a reference (memory address) to the location where the actual data is stored in memory.
    
    Object: The most fundamental non-primitive type, used to store collections of key-value pairs. Arrays and functions are special types of objects.
    example:
        let person = {
            firstName: "John",
            lastName: "Doe"
        };

    Array: An ordered collection of values, indexed numerically. Arrays are a specific type of object.
    example:
        let colors = ["red", "green", "blue"];

    Function: A block of code designed to perform a particular task. Functions are also a type of object.
    example:
        function greet(name) {
            return "Hello, " + name;
        }



3. What is the difference between var, let, and const? 
The main difference is that var has function scope, while let and const have block scope. 
var can be reassigned and redecalred, let can be reassigned but not redeclared in the same scope, 
and const cannot be reassigned or redeclared after initialization. 

Feature 	                            var	                                    let	                                                const
Scope	                                Function scope	                        Block scope	                                        Block scope
Reassignable	                        Yes	                                    Yes	                                                No
Redeclarable	                        Yes	                                    No	                                                No
Hoisting	                            Hoisted and initializedto undefined	    Hoisted but not initialized (Temporal Dead Zone)	Hoisted but not initialized (Temporal Dead Zone)

    // var example
    function varExample() {
    var x = 1;
    if (true) {
        var x = 10; // Reassigns the outer 'x'
        console.log("Inside block:", x); // Output: 10
    }
    console.log("Outside block:", x); // Output: 10 (x was changed globally)
    }
    varExample();


    // let example
    function letExample() {
    let y = 2;
    if (true) {
        let y = 20; // Creates a new 'y' with block scope
        console.log("Inside block:", y); // Output: 20
    }
    console.log("Outside block:", y); // Output: 2 (the original 'y' is untouched)
    }
    letExample();


    // const example
    function constExample() {
    const PI = 3.14;
    // PI = 3.14159; // This would cause an error
    console.log(PI);

    const MY_OBJECT = { value: 1 };
    // MY_OBJECT = { value: 2 }; // This would cause an error
    MY_OBJECT.value = 2; // You can still change the contents of the object
    console.log(MY_OBJECT.value); // Output: 2
    }
    constExample();



What is hoisting?
    Hoisting in JavaScript is a mechanism where variable and function declarations are conceptually moved to the top of their containing scope during the compile phase, before the code is executed. This means that you can use variables and call functions before they are formally declared in your code. 
    Here's a breakdown of how hoisting works for different types of declarations:
    
    1. Variable Hoisting (with var)
    Declarations are hoisted, initializations are not. When you declare a variable with var, only the declaration is hoisted to the top of its scope. The assignment or initialization of the value remains in its original position.
    Default value of undefined. If you access a var variable before its initialization, it will have the value undefined. 
    ex:

    console.log(myVar); // Output: undefined
    var myVar = 10;
    console.log(myVar); // Output: 10
    
    2. Variable Hoisting (with let and const)
    Declarations are hoisted, but they are in a "Temporal Dead Zone" (TDZ). let and const declarations are also hoisted, but unlike var, they are not initialized with undefined. Attempting to access them before their actual declaration line will result in a ReferenceError.
    Block-scoped. let and const are block-scoped, meaning their scope is limited to the block in which they are declared. 
    ex:
    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
    let myLet = 20;
    console.log(myLet); // Output: 20

    // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
    const myConst = 30;
    console.log(myConst); // Output: 30
    
    3. Function Hoisting
    Function declarations are fully hoisted. Both the function name and its definition are hoisted to the top of their containing scope. This allows you to call a function declaration before it is defined in the code.
    ex:

    greet(); // Output: Hello!

    function greet() {
    console.log("Hello!");
    }
    Function expressions are treated like variable hoisting. If you define a function as a function expression (assigning an anonymous function to a variable), the hoisting behavior follows that of the variable declaration (var, let, or const) used.
    JavaScript

    // sayHi(); // TypeError: sayHi is not a function (if using var) or ReferenceError (if using let/const)

    var sayHi = function() {
    console.log("Hi!");
    };

    sayHi(); // Output: Hi!


5. What is the difference between == and ===?
The main difference is that = is the assignment operator, which assigns a value to a variable, while == is the loose equality operator, which compares 
two values for equality after converting them to a common type. In contrast, === is the strict equality operator, which checks for equality without any type conversion, 
requiring both the value and the data type to be identical. 

6. What are truthy and falsy values in JavaScript?

    Falsy Values:
    Falsy values are those that are considered false when evaluated in a Boolean context. There are a specific, limited set of falsy values in JavaScript: 
    false: The boolean primitive false.
    0: The number zero (including -0).
    0n: The BigInt zero.
    "": An empty string.
    null: Represents the intentional absence of any object value.
    undefined: A variable that has not been assigned a value.
    NaN: "Not a Number," a result of an invalid or undefined mathematical operation.
    Truthy Values:
    Truthy values are all values that are not specifically defined as falsy. When evaluated in a Boolean context, they are considered true. This includes:
    true: The boolean primitive true.
    Any non-zero number (e.g., 1, -5, 3.14).
    Any non-empty string (e.g., "hello", "false", "0").
    Objects (e.g., {}, [], new Date()).
    Arrays (even empty ones, []).
    Functions.

    Example:


    if (0) {
    console.log("This will not execute because 0 is falsy.");
    }

    if ("hello") {
    console.log("This will execute because 'hello' is truthy.");
    }

    let myVariable;
    if (myVariable) {
    console.log("This will not execute because myVariable is undefined (falsy).");
    }

    if ({}) {
    console.log("This will execute because an empty object is truthy.");
    }


7. What is the use of the typeof operator?

The typeof operator is used to determine the data type of a variable or expression. It returns a string indicating the type of its operand. This is particularly useful in dynamically typed languages like JavaScript, where variable types are not explicitly declared and can change during runtime. 
Primary uses of the typeof operator:

Type Checking: It allows developers to check the data type of a variable or value before performing operations that are specific to that type. This helps prevent errors and ensures code robustness.
ex:

    let myVariable = "Hello";
    if (typeof myVariable === "string") {
        console.log("It's a string!");
    }
Debugging: When debugging, typeof can be used to quickly inspect the type of a variable at a particular point in the code, helping to identify unexpected type assignments or conversions.
Conditional Logic: It enables the creation of conditional logic that executes different code paths based on the type of data being processed.
ex:

    function processData(data) {
        if (typeof data === "number") {
            return data * 2;
        } else if (typeof data === "string") {
            return data.toUpperCase();
        } else {
            return "Unsupported type";
        }
    }
Handling Undefined Variables: It can safely check if a variable is declared and defined, preventing ReferenceError when attempting to access a potentially non-existent variable.
ex:

    if (typeof nonExistentVar === "undefined") {
        console.log("nonExistentVar is not defined.");
    }


8. What is NaN and how can you check for it?

    NaN, which stands for "Not a Number," is a special floating-point value that represents an undefined or unrepresentable numeric result, 
    like the square root of a negative number or \(0/0\). The most reliable way to check for NaN is to use specific functions, as NaN is the only value that is not equal 
    to itself, though methods like isNaN() or Number.isNaN() (in JavaScript) are commonly used for this purpose. 

    What is NaN? 
    Undefined Result: NaN typically arises from mathematical operations that don't produce a real number, such as taking the square root of a negative
    number or dividing zero by zero.Missing Data: It can also be used to represent missing or undefined values in computations and data analysis.
    Floating-Point Standard: The use of NaN was standardized by the IEEE 754 floating-point standard. How to check for NaN Because of its unique properties,
    you cannot check for NaN with a simple equality test (== or ===). Instead, you must use specific functions provided by your programming language.
     
    JavaScript:
    Use Number.isNaN() for a reliable check, which returns true only if the value is NaN.
    Use the global isNaN(), but be aware it will return true for any value that cannot be converted to a number (not just NaN).


 9. What is the difference between undefined and null?

    The difference between undefined and null lies in their origin and intended meaning, particularly in JavaScript:
    undefined: This indicates that a variable has been declared but has not yet been assigned a value. It is implicitly assigned by JavaScript in several scenarios:
    When a variable is declared without initialization: let x;

    When accessing an object property that does not exist: console.log(obj.nonExistentProperty);
    When a function does not explicitly return a value: function foo() {}
    For function parameters that are not provided: function bar(a, b) { console.log(b); } bar(1);
    
    null: This represents the intentional absence of any object value. It is explicitly assigned by a developer to indicate that a variable or property currently 
    holds no value.

    let myVariable = null;
    document.getElementById('someElement').onclick = null;

10. What is type coercion in JavaScript?

    Type coercion in JavaScript refers to the automatic or implicit conversion of values from one data type to another during certain operations. 
    This happens when JavaScript encounters an operation involving values of different types and needs to convert one or both of them to a compatible type to
    perform the operation. 
    
    How it works:
    JavaScript is a loosely typed language, meaning variables are not explicitly declared with a specific data type. This flexibility allows for type coercion to occur naturally in many scenarios:
    Arithmetic operations: When you perform an operation like number + string, JavaScript will often coerce the number into a string to concatenate them. 
    
    For example, 5 + "hello" results in "5hello".
    Comparison operations: When using the loose equality operator (==), JavaScript attempts to convert operands to a common type before comparing their values. For example, 5 == "5" evaluates to true because the string "5" is coerced to the number 5.
    Logical operations: In contexts where a boolean value is expected (e.g., if statements, logical operators like && or ||), non-boolean values are coerced to booleans. For example, if ("hello") will evaluate to true because a non-empty string is truthy.
    
    Types of Coercion:
    
    Implicit Coercion: This is the automatic conversion performed by JavaScript without explicit instructions from the developer. The examples above 
    illustrate implicit coercion.

    Explicit Coercion (Type Casting): This involves deliberately converting a value from one type to another using built-in functions or constructors like Number(), 
    String(), or Boolean(). For example, Number("10") converts the string "10" to the number 10.