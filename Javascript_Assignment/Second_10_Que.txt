1. Explain global scope, function scope, and block scope. 

    Global Scope:
    Global scope refers to the outermost scope of a JavaScript program.
    Any variable or function declared outside of all functions or blocks is placed in the global scope.
    Such variables become accessible from anywhere in the program, including inside functions and blocks.

    Global variables live for the entire life of the program and are stored on the global object (window in browser, global in Node.js).
    Overusing global scope can lead to naming conflicts and debugging issues.

    ex: 

    var x = 10; // global variable

    function printX() {
    console.log(x); // accessible
    }

    printX();   // 10
    console.log(x); // 10


    Function Scope:
    Function scope means that variables declared inside a function (using var, let, or const) can be accessed only within that function.
    They are not accessible outside the function, regardless of where the function is invoked.

    Function scope allows logical grouping of code and prevents variable conflicts by confining variables within functional boundaries.

    ex: 

    function test() {
    var a = 20;   // function scoped
    console.log(a); 
    }

    test();       // 20
    console.log(a);


    Block scope:
    Block scope applies to variables declared inside {} such as loops, if statements, and switch blocks.
    Only let and const create block-scoped variables; var does not.
    Block-scoped variables exist only within the block in which they are defined.

    Block scope enables finer control of a variable's lifetime and helps avoid accidental reassignments.

    ex:

    if (true) {
    let b = 30;
    const c = 40;
    var d = 50;
    }

    console.log(d); 
    console.log(b); 
    console.log(c); 



2. How does hoisting work for variables and functions? 

    Hoisting in JavaScript is a mechanism where variable and function declarations are conceptually moved to the top of their containing scope during the compile phase, 
    before the code is executed. This means that you can use variables and functions before they are formally declared in your code, though with different behaviors 
    depending on the declaration type. 
    
    Function Hoisting:
    Function declarations are fully hoisted, meaning both the function's name and its definition are moved to the top of the scope. 
    This allows you to call a function before its declaration appears in the code.
    
    ex:

    greet(); // Outputs: "Hello!"

    function greet() {
    console.log("Hello!");
    }

    However, function expressions (where a function is assigned to a variable) are treated like variable hoisting, meaning only the variable declaration is hoisted, 
    not the function definition itself.
    
    // sayHi(); // TypeError: sayHi is not a function

    var sayHi = function() {
    console.log("Hi!");
    };
    sayHi(); // Outputs: "Hi!"


    Variable Hoisting:
    The behavior of variable hoisting depends on how the variable is declared: 
    var: Variables declared with var are hoisted to the top of their function or global scope. The declaration is hoisted, but the initialization
     (assignment of a value) remains in its original position. This means if you access a var variable before its initialization, it will be undefined.
    ex:

        console.log(myVar); // Outputs: undefined
        var myVar = 10;
        console.log(myVar); // Outputs: 10

    let and const: Variables declared with let and const are also hoisted, but they are not initialized. They exist in a "Temporal Dead Zone" (TDZ) from the beginning of their scope until their declaration line is reached. Attempting to access a let or const variable within the TDZ will result in a ReferenceError. 
    ex:

        // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
        let myLet = 20;
        console.log(myLet); // Outputs: 20

        // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
        const myConst = 30;
        console.log(myConst); // Outputs: 30



3. What happens if you use a variable before declaring it? 

    With var, accessing a variable before declaration returns undefined.

    With let or const, accessing a variable before declaration causes a ReferenceError due to the TDZ.

    This difference is crucial in preventing accidental use of variables before they are ready.

    ex:
    console.log(x); // undefined
    var x = 5;

    console.log(y); // ReferenceError
    let y = 6;


4. What is lexical scope? 

    Lexical scope means a function's scope is determined by where it is written in the code, not where it is called.

    Inner functions can access outer function variables.

    Inner functions can access variables from their:

    Own scope

    Parent functionâ€™s scope

    Global scope

    Lexical scope does NOT depend on where a function is invoked, only where it is defined.

    ex: function outer() {
    let msg = "Hello";

    function inner() {
        console.log(msg); // inner can access outer
    }

    inner();
    }

    outer();  // Hello


5.How do closures work in JavaScript? 
    A closure in JavaScript is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment).
    In simpler terms, a closure allows an inner function to access the variables and parameters of its outer function,
    even after the outer function has finished executing. This occurs because the inner function "remembers" the environment in which it was created

    ex: 

    function createCounter() {
    let count = 0; // 'count' is a variable in the outer function's scope

    return function() { // This is the inner function, forming the closure
        count++;
        console.log(count);
    };
    }

    const counter1 = createCounter(); // 'counter1' now holds the inner function
    const counter2 = createCounter(); // 'counter2' holds a *separate* inner function

    counter1(); // Output: 1
    counter1(); // Output: 2

    counter2(); // Output: 1 (starts a new count for counter2)
    counter1(); // Output: 3 (counter1 continues its own count)


    Workflow of a Closure:
    Outer Function Execution and Variable Creation:
    An outer function is called and begins its execution.
    Inside this outer function, local variables are declared. These variables become part of the outer function's lexical environment.

    Inner Function Definition and Return:
    An inner (nested) function is defined within the outer function.
    Crucially, this inner function references one or more of the outer function's local variables.
    The outer function then returns this inner function.

    Outer Function Completes, Scope Remains:
    After the outer function returns the inner function, the outer function's execution context normally would be destroyed, 
    and its local variables would be garbage collected.
    However, because the returned inner function still holds a reference to the outer function's lexical environment (specifically, the variables it uses), 
    that environment is preserved and not garbage collected. This preserved environment, along with the inner function, forms the closure.
    
    Inner Function Invocation and Variable Access:
    Later, the returned inner function is invoked.
    When the inner function executes, it accesses the variables from its closed-over lexical environment, which includes the variables from the outer function's scope at the time the inner function was created.
    These variables can be read and even modified by the inner function, and their state persists across multiple calls to the inner function.



6. What is the difference between var, let, and const in terms of hoisting? 

    var and Hoisting:
    Hoisting Behavior: var declarations are hoisted to the top of their function or global scope. During hoisting, they are automatically initialized with undefined.
    Accessibility Before Declaration: Because var variables are initialized to undefined during hoisting, they can be accessed before their 
    declaration in the code without causing an error. The value will be undefined until the actual declaration line is reached and a value is assigned. 
    ex:

    console.log(myVar); // Output: undefined
    var myVar = "Hello";
    console.log(myVar); // Output: Hello

    2. let and const and Hoisting (Temporal Dead Zone):
    Hoisting Behavior: let and const declarations are also hoisted to the top of their block scope. However, unlike var, they are not initialized with a default value during hoisting.
    Temporal Dead Zone (TDZ): The period between the start of the block scope and the actual declaration line of a let or const variable is known as the Temporal Dead Zone (TDZ). 
    During this time, attempting to access the variable will result in a ReferenceError.
    Accessibility Before Declaration: let and const variables cannot be accessed before their declaration line is reached and they are initialized with a value. 
    ex:

    // Example with let
    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
    let myLet = "World";
    console.log(myLet); // Output: World

    // Example with const
    // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
    const myConst = 123;
    console.log(myConst); // Output: 123
     Differences in Hoisting:
    
    Feature                                                    var                                                  let and const
    Hoisting                                                   Hoisted to top of function/global scope              Hoisted to top of block scope
    Initialization                                             Initialized with undefined                           Not initialized during hoisting (TDZ)
    Accessibility                                              Accessible before declaration (value undefined)      Not accessible before declaration (ReferenceError)


7. What are temporal dead zones (TDZ)? 

    A temporal dead zone (TDZ) is a period in JavaScript where a variable declared with let or const cannot be accessed before its actual declaration is executed. 
    This period starts at the beginning of a block scope and ends when the variable is initialized. Accessing a variable in its TDZ results in a ReferenceError, 
    but variables declared with var are initialized as undefined and do not have a TDZ. 

    ex:
    let myVar = "I am initialized";

    console.log(myVar); 


8. What are immediately invoked function expressions (IIFEs)? 

    An Immediately Invoked Function Expression (IIFE) is a JavaScript function that is defined and runs as soon as it is created. 
    It is created by wrapping a function expression in parentheses () and is immediately executed by adding another set of parentheses () at the end. 
    This pattern creates a private scope for variables, preventing them from polluting the global scope, which helps in avoiding naming conflicts and organizing code. 

    ex:

    var counter = (function() {
    var count = 0; // This variable is private to the IIFE
    return {
        increment: function() {
        count++;
        console.log(count);
        },
        getCount: function() {
        return count;
        }
    };
    })();

    // Calling the increment function from the returned object
    counter.increment(); // Output: 1
    counter.increment(); // Output: 2

    // Trying to access the private variable directly will fail
    console.log(counter.count); // Output: undefined


9. What is a pure function? 

    A pure function is a function that adheres to two main principles: 
    
    Deterministic Output: Given the same input arguments, a pure function will always produce the same output. 
    It does not rely on any external state or mutable data that could change its behavior over time.
    
    No Side Effects: A pure function does not cause any observable side effects outside its own scope. 
    This means it does not modify global variables, mutate its input arguments, perform I/O operations (like printing to the console or writing to a file), or interact with external systems.

    ex:
    function add(a, b) {
    return a + b;
    }

    This add function is a pure function because:
    Deterministic Output: If you call add(2, 3), it will always return 5. The output is solely determined by its input arguments.
    No Side Effects: It does not modify any variables outside its scope, nor does it perform any other actions that would change the state of the program.
     It simply returns a new value based on its inputs.


10. What is a higher-order function?

    A higher-order function is a function that either takes one or more functions as arguments, or returns a function as its result, or both. 
    This concept is fundamental to functional programming paradigms and is readily available in JavaScript due to its support for first-class functions

    ex: 
    // Higher-order function that takes an array and an operation function
    function applyOperationToArray(arr, operation) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(operation(arr[i]));
    }
    return result;
    }

    // Example operation functions (can be passed to applyOperationToArray)
    function square(num) {
    return num * num;
    }

    function double(num) {
    return num * 2;
    }

    function addTen(num) {
    return num + 10;
    }

    const numbers = [1, 2, 3, 4, 5];

    // Using the higher-order function with different operations
    const squaredNumbers = applyOperationToArray(numbers, square);
    console.log("Squared numbers:", squaredNumbers); // Output: [1, 4, 9, 16, 25]

    const doubledNumbers = applyOperationToArray(numbers, double);
    console.log("Doubled numbers:", doubledNumbers); // Output: [2, 4, 6, 8, 10]

    const addedTenNumbers = applyOperationToArray(numbers, addTen);
    console.log("Numbers plus ten:", addedTenNumbers); // Output: [11, 12, 13, 14, 15]


    Popular Higher Order Functions in JavaScript

    1. map
    The map function is used to transform an array by applying a callback function to each element. It returns a new array.

    const n = [1, 2, 3, 4, 5];
    const square = n.map((num) => num * num);
    console.log(square);
    map applies the callback (num) => num * num to each element of numbers.
    A new array is returned where each element is the square of the original

    2. filter
    The filter function is used to create a new array containing elements that satisfy a given condition.

    const n = [1, 2, 3, 4, 5];
    const even = n.filter((num) => num % 2 === 0);
    console.log(even);
    The callback (num) => num % 2 === 0 filters out elements not divisible by 2.
    The resulting array contains only even numbers.

    3. reduce
    The reduce function accumulates array elements into a single value based on a callback function.

    const n = [1, 2, 3, 4, 5];
    const sum = n.reduce((acc, curr) => acc + curr, 0);
    console.log(sum);
    The callback (acc, curr) => acc + curr adds all elements.
    0 is the initial value of the acc.

    4. forEach
    The forEach function executes a provided function once for each array element.

    const n = [1, 2, 3];
    n.forEach((num) => console.log(num * 2));
    forEach performs the side effect of printing each element multiplied by 2.
    It does not return a new array like map.

    5. find
    The find function returns the first element in the array that satisfies a given condition.

    const n = [1, 2, 3, 4, 5];
    const fEven = n.find((num) => num % 2 === 0);
    console.log(fEven);
    The callback (num) => num % 2 === 0 finds the first even number.
    If no element satisfies the condition, it returns undefined.

    6. some
    The some function checks if at least one array element satisfies a condition.

    const n = [1, 2, 3, 4, 5];
    const hasNeg = n.some((num) => num < 0);
    console.log(hasNeg);
    The callback (num) => num < 0 checks for negative numbers.
    It returns true if any element passes the condition, false otherwise.

    7. every
    The every function checks if all array elements satisfy a condition.

    const n = [1, 2, 3, 4, 5];
    const allPos = n.every((num) => num > 0);
    console.log(allPos)
    The callback (num) => num > 0 checks if all numbers are positive.
    It returns true only if all elements pass the condition.