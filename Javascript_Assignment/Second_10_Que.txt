1. Explain global scope, function scope, and block scope. 

    Global Scope:
    Global scope refers to the outermost scope of a JavaScript program.
    Any variable or function declared outside of all functions or blocks is placed in the global scope.
    Such variables become accessible from anywhere in the program, including inside functions and blocks.

    ex: 

    var x = 10; // global variable

    function printX() {
    console.log(x); // accessible
    }

    printX();   // 10
    console.log(x); // 10


    Function Scope:
    Function scope means that variables declared inside a function (using var, let, or const) can be accessed only within that function.
    They are not accessible outside the function, regardless of where the function is invoked.
    ex: 

    function test() {
    var a = 20;   // function scoped
    console.log(a); 
    }

    test();  // 20
    console.log(a);

    Block scope:
    Block scope applies to variables declared inside {} such as loops, if statements, and switch blocks.
    Only let and const create block-scoped variables; var does not.
    Block-scoped variables exist only within the block in which they are defined.

    ex:

    if (true) {
    let b = 30;
    const c = 40;
    var d = 50;
    }

    console.log(d); 
    console.log(b); 
    console.log(c); 



2. How does hoisting work for variables and functions? 

    Hoisting in JavaScript is a mechanism where variable and function declarations are conceptually moved to the top of their containing scope during the compile phase, 
    before the code is executed. This means that you can use variables and functions before they are formally declared in your code, though with different behaviors 
    depending on the declaration type. 
    
    Function Hoisting:
    Function declarations are fully hoisted, meaning both the function's name and its definition are moved to the top of the scope. 
    This allows you to call a function before its declaration appears in the code.
    
    ex:

    greet(); // Outputs: "Hello!"

    function greet() {
    console.log("Hello!");
    }

    However, function expressions (where a function is assigned to a variable) are treated like variable hoisting, meaning only the variable declaration is hoisted, 
    not the function definition itself.
    
    // sayHi(); // TypeError: sayHi is not a function

    var sayHi = function() {
    console.log("Hi!");
    };
    sayHi(); // Outputs: "Hi!"


    Variable Hoisting:
    The behavior of variable hoisting depends on how the variable is declared: 
    var: Variables declared with var are hoisted to the top of their function or global scope. The declaration is hoisted, but the initialization
     (assignment of a value) remains in its original position. This means if you access a var variable before its initialization, it will be undefined.
    ex:

        console.log(myVar); // Outputs: undefined
        var myVar = 10;
        console.log(myVar); // Outputs: 10

    let and const: Variables declared with let and const are also hoisted, but they are not initialized. They exist in a "Temporal Dead Zone" (TDZ) from the beginning of their scope until their declaration line is reached. Attempting to access a let or const variable within the TDZ will result in a ReferenceError. 
    ex:

        // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
        let myLet = 20;
        console.log(myLet); // Outputs: 20

        // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
        const myConst = 30;
        console.log(myConst); // Outputs: 30



3. What happens if you use a variable before declaring it? 

    With var, accessing a variable before declaration returns undefined.

    With let or const, accessing a variable before declaration causes a ReferenceError due to the TDZ.

    This difference is crucial in preventing accidental use of variables before they are ready.

    ex:
    console.log(x); // undefined
    var x = 5;

    console.log(y); // ReferenceError
    let y = 6;


4. What is lexical scope? 

    Lexical scope means a function's scope is determined by where it is written in the code, not where it is called.
    or
    JavaScript looks at where the function is written, and based on that placement, it decides which variables are accessible inside that function.

    Inner functions can access outer function variables.

    Lexical scope is a powerful concept that can help to make your code more readable and maintainable. 
    By understanding lexical scope, you can avoid the problems that can be caused by global variables and other forms of uncontrolled scope.

    Benefits of Lexical Scope

    Increased readability: Lexical scope makes your code more readable by making it clear where variables are defined and what their scope is. 
    This can help to prevent errors and make your code easier to understand.
    
    Improved maintainability: Lexical scope makes your code more maintainable by making it easier to change variables without affecting other parts of your code. 

    Declaring variables outside of functions: Variables should always be declared inside of functions, not outside of functions. 
    
    ex: function outer() {
    let msg = "Hello";

    function inner() {
        console.log(msg); // inner can access outer
    }

    inner();
    }

    outer();  // Hello


5.How do closures work in JavaScript? 
    In JavaScript, closure provides access to the outer scope of a function from inside the inner function, even after the outer function has closed.
    or
    In simpler terms, a closure allows an inner function to access the variables and parameters of its outer function,
    even after the outer function has finished executing. This occurs because the inner function "remembers" the environment in which it was created

    ex: 

    function createCounter() {
    let count = 0; // 'count' is a variable in the outer function's scope

    return function() { // This is the inner function, forming the closure
        count++;
        console.log(count);
    };
    }

    const counter1 = createCounter(); // 'counter1' now holds the inner function
    const counter2 = createCounter(); // 'counter2' holds a *separate* inner function

    counter1(); // Output: 1
    counter1(); // Output: 2

    counter2(); // Output: 1 (starts a new count for counter2)
    counter1(); // Output: 3 (counter1 continues its own count)


    Workflow of a Closure:
    Outer Function Execution and Variable Creation:
    An outer function is called and begins its execution.
    Inside this outer function, local variables are declared. These variables become part of the outer function's lexical environment.

    Inner Function Definition and Return:
    An inner (nested) function is defined within the outer function.
    Crucially, this inner function references one or more of the outer function's local variables.
    The outer function then returns this inner function.

    Outer Function Completes, Scope Remains:
    After the outer function returns the inner function, the outer function's execution context normally would be destroyed, 
    and its local variables would be garbage collected.
    However, because the returned inner function still holds a reference to the outer function's lexical environment (specifically, the variables it uses), 
    that environment is preserved and not garbage collected. This preserved environment, along with the inner function, forms the closure.
    
    Inner Function Invocation and Variable Access:
    Later, the returned inner function is invoked.
    When the inner function executes, it accesses the variables from its closed-over lexical environment, which includes the variables from the outer function's scope at the time the inner function was created.
    These variables can be read and even modified by the inner function, and their state persists across multiple calls to the inner function.



6. What is the difference between var, let, and const in terms of hoisting? 

    var and Hoisting:
    Hoisting Behavior: var declarations are hoisted to the top of their function or global scope. During hoisting, they are automatically initialized with undefined.
    Accessibility Before Declaration: Because var variables are initialized to undefined during hoisting, they can be accessed before their 
    declaration in the code without causing an error. The value will be undefined until the actual declaration line is reached and a value is assigned. 
    ex:

    console.log(myVar); // Output: undefined
    var myVar = "Hello";
    console.log(myVar); // Output: Hello

    2. let and const and Hoisting (Temporal Dead Zone):
    Hoisting Behavior: let and const declarations are also hoisted to the top of their block scope. However, unlike var, they are not initialized with a default value during hoisting.
    Temporal Dead Zone (TDZ): The period between the start of the block scope and the actual declaration line of a let or const variable is known as the Temporal Dead Zone (TDZ). 
    During this time, attempting to access the variable will result in a ReferenceError.
    Accessibility Before Declaration: let and const variables cannot be accessed before their declaration line is reached and they are initialized with a value. 
    ex:

    // Example with let
    // console.log(myLet); // ReferenceError: Cannot access 'myLet' before initialization
    let myLet = "World";
    console.log(myLet); // Output: World

    // Example with const
    // console.log(myConst); // ReferenceError: Cannot access 'myConst' before initialization
    const myConst = 123;
    console.log(myConst); // Output: 123
     Differences in Hoisting:
    
    Feature                                                    var                                                  let and const
    Hoisting                                                   Hoisted to top of function/global scope              Hoisted to top of block scope
    Initialization                                             Initialized with undefined                           Not initialized during hoisting (TDZ)
    Accessibility                                              Accessible before declaration (value undefined)      Not accessible before declaration (ReferenceError)


7. What are temporal dead zones (TDZ)? 

    A temporal dead zone (TDZ) is a period in JavaScript where a variable declared with let or const cannot be accessed before its actual declaration is executed. 
    This period starts at the beginning of a block scope and ends when the variable is initialized. Accessing a variable in its TDZ results in a ReferenceError, 
    but variables declared with var are initialized as undefined and do not have a TDZ. 

    ex:
    let myVar = "I am initialized";

    console.log(myVar); 


8. What are immediately invoked function expressions (IIFEs)? 

    An Immediately Invoked Function Expression (IIFE) is a JavaScript function that is defined and runs as soon as it is created. 
    It is created by wrapping a function expression in parentheses () and is immediately executed by adding another set of parentheses () at the end. 
    This pattern creates a private scope for variables, preventing them from polluting the global scope, which helps in avoiding naming conflicts and organizing code. 

    How it works
    Function expression: The function is wrapped in parentheses () to be treated as an expression, not a declaration. For example: (function() { ... }).
    Immediate invocation: A second set of parentheses () is added to the end to execute the function immediately after it's created. 

    Why use an IIFE?
    Avoids global scope pollution: Variables declared with var inside an IIFE stay local to the function, preventing them from becoming global variables. Using let or const is recommended for this purpose.
    Creates a private scope: It's a way to encapsulate code and its variables without leaving any trace in the global scope.
    Prevents naming conflicts: By creating its own scope, an IIFE ensures that variables inside it don't clash with variables outside of it. 

    ex:

    var counter = (function() {
    var count = 0; // This variable is private to the IIFE
    return {
        increment: function() {
        count++;
        console.log(count);
        },
        getCount: function() {
        return count;
        }
    };
    })();

    // Calling the increment function from the returned object
    counter.increment(); // Output: 1
    counter.increment(); // Output: 2

    // Trying to access the private variable directly will fail
    console.log(counter.count); // Output: undefined


9. What is a pure function? 

    A pure function in JavaScript is a function that always gives the same output for the same input and does not cause any side effects.

    Definition of a Pure Function

    A function is considered pure if it satisfies both conditions:

    1. Same input → Same output (Deterministic)

    No matter how many times you call the function with the same arguments, the result must always be the same.

    2. No side effects

    The function should not modify:

    Global variables

    Function parameters

    DOM elements

    Files / Databases

    API Calls

    Console logs (ideally avoided)

    It should only depend on its input and return a value.

    Pure Function Example 
    function add(a, b) {
    return a + b;
    }

    console.log(add(2, 3)); // 5
    console.log(add(2, 3)); // 5 (same input → same output)

10. What is a higher-order function?

    A higher-order function is a function that either takes one or more functions as arguments, or returns a function as its result, or both. 
    This concept is fundamental to functional programming paradigms and is readily available in JavaScript due to its support for first-class functions

    ex: 
    // Higher-order function that takes an array and an operation function
    function applyOperationToArray(arr, operation) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        result.push(operation(arr[i]));
    }
    return result;
    }

    // Example operation functions (can be passed to applyOperationToArray)
    function square(num) {
    return num * num;
    }

    function double(num) {
    return num * 2;
    }

    function addTen(num) {
    return num + 10;
    }

    const numbers = [1, 2, 3, 4, 5];

    // Using the higher-order function with different operations
    const squaredNumbers = applyOperationToArray(numbers, square);
    console.log("Squared numbers:", squaredNumbers); // Output: [1, 4, 9, 16, 25]

    const doubledNumbers = applyOperationToArray(numbers, double);
    console.log("Doubled numbers:", doubledNumbers); // Output: [2, 4, 6, 8, 10]

    const addedTenNumbers = applyOperationToArray(numbers, addTen);
    console.log("Numbers plus ten:", addedTenNumbers); // Output: [11, 12, 13, 14, 15]


    Popular Higher Order Functions in JavaScript

    1. map
    The map function is used to transform an array by applying a callback function to each element. It returns a new array.

    const n = [1, 2, 3, 4, 5];
    const square = n.map((num) => num * num);
    console.log(square);
    map applies the callback (num) => num * num to each element of numbers.
    A new array is returned where each element is the square of the original

    2. filter
    The filter function is used to create a new array containing elements that satisfy a given condition.

    const n = [1, 2, 3, 4, 5];
    const even = n.filter((num) => num % 2 === 0);
    console.log(even);
    The callback (num) => num % 2 === 0 filters out elements not divisible by 2.
    The resulting array contains only even numbers.

    3. reduce
    The reduce function accumulates array elements into a single value based on a callback function.

    const n = [1, 2, 3, 4, 5];
    const sum = n.reduce((acc, curr) => acc + curr, 0);
    console.log(sum);
    The callback (acc, curr) => acc + curr adds all elements.
    0 is the initial value of the acc.

    4. forEach
    The forEach function executes a provided function once for each array element.

    const n = [1, 2, 3];
    n.forEach((num) => console.log(num * 2));
    forEach performs the side effect of printing each element multiplied by 2.
    It does not return a new array like map.

    5. find
    The find function returns the first element in the array that satisfies a given condition.

    const n = [1, 2, 3, 4, 5];
    const fEven = n.find((num) => num % 2 === 0);
    console.log(fEven);
    The callback (num) => num % 2 === 0 finds the first even number.
    If no element satisfies the condition, it returns undefined.

    6. some
    The some function checks if at least one array element satisfies a condition.

    const n = [1, 2, 3, 4, 5];
    const hasNeg = n.some((num) => num < 0);
    console.log(hasNeg);
    The callback (num) => num < 0 checks for negative numbers.
    It returns true if any element passes the condition, false otherwise.

    7. every
    The every function checks if all array elements satisfy a condition.

    const n = [1, 2, 3, 4, 5];
    const allPos = n.every((num) => num > 0);
    console.log(allPos)
    The callback (num) => num > 0 checks if all numbers are positive.
    It returns true only if all elements pass the condition.